@(generator: com.linkedin.sleipnir.generator.types.RecordTypeGenerator)

@import _root_.scala.collection.JavaConverters._
@import _root_.com.linkedin.data.schema.RecordDataSchema.Field
@import _root_.com.linkedin.data.schema.PrimitiveDataSchema
@import _root_.com.linkedin.data.schema.RecordDataSchema
@import _root_.com.linkedin.data.schema.UnionDataSchema
@import _root_.com.linkedin.data.schema.FixedDataSchema
@import _root_.com.linkedin.data.schema.EnumDataSchema
@import _root_.com.linkedin.data.schema.ArrayDataSchema
@import _root_.com.linkedin.data.schema.MapDataSchema
@import _root_.com.linkedin.sleipnir.generator.types.TypeGenerator
@import _root_.com.linkedin.sleipnir.generator.types.TypeGeneratorFactory

package @(generator.name.packageName)

import scala.collection.JavaConverters._

import com.linkedin.data.DataMap
import com.linkedin.data.schema.RecordDataSchema
import com.linkedin.data.template.DataTemplateUtil
import com.linkedin.data.template.GetMode
import com.linkedin.sleipnir.data.ScalaRecordTemplate


import @(generator.name.shortClassName)._

/**
 * @(generator.schema.getDoc)
 */
class @(generator.name.shortClassName)(data: DataMap) extends ScalaRecordTemplate(data, Schema) {

  def this(@(generator.constructorArgs)) = {
    this(new DataMap())
    @for(field <- generator.schema.getFields.asScala) {
      @setter(field)
    }
  }

@for(field <- generator.schema.getFields.asScala) {

  /**
   * @(field.getDoc)
   */
  def @(field.getName): @(generator.recordTypeOf(field)) = {
    @getter(field)
  }

}

}

object @(generator.name.shortClassName) {

  private val SchemaJson = "@(generator.schemaJson)"

  private val Schema = DataTemplateUtil.parseSchema(SchemaJson).asInstanceOf[RecordDataSchema]

@for(field <- generator.schema.getFields.asScala) {
  private val @(generator.fieldValName(field)) = Schema.getField("@(field.getName)")
}

  def apply(@(generator.constructorArgs)) = new @(generator.name.shortClassName)(@generator.constructorParams)

}

@***********
 * Setters *
 ***********@

@setter(field: Field) = {
  @if(field.getOptional) {
    @(field.getName).foreach {
      @setterWithType(generator.fieldValName(field), "_", generator.fieldGenerator(field))
    }
  } else {
    @setterWithType(generator.fieldValName(field), field.getName, generator.fieldGenerator(field))
  }
}

@setterWithType(fieldName: String, valueName: String, fieldGenerator: TypeGenerator) = {
  @(fieldGenerator.schema.getDereferencedDataSchema) match {

    case _ : PrimitiveDataSchema => {
      putDirect(@(fieldName), classOf[@(fieldGenerator.name.externalClassName)], @(valueName))
    }

    case _ : RecordDataSchema | _ : FixedDataSchema | _ : UnionDataSchema => {
      putWrapped(@(fieldName), classOf[@(fieldGenerator.name.externalClassName)], @(valueName))
    }

    case _ : EnumDataSchema => {
      putDirect(@(fieldName), classOf[String], @(valueName).toString)
    }

    case array : ArrayDataSchema => {
      @if(array.getItems.isComplex) {
        putWrapped(@(fieldName), classOf[@(fieldGenerator.name.fullClassName)], @(fieldGenerator.name.fullClassName)(@(valueName)))
      } else {
        putWrapped(@(fieldName), classOf[@(fieldGenerator.name.fullClassName)], new @(fieldGenerator.name.fullClassName)(@(valueName).asJavaCollection))
      }
    }

    case map : MapDataSchema => {
      @if(map.getValues.isComplex) {
        val wrapper = @(fieldGenerator.name.fullClassName)(@(valueName))
        putWrapped(@(fieldName), classOf[@(fieldGenerator.name.fullClassName)], wrapper)
      } else {
        val wrapper = new @(fieldGenerator.name.fullClassName)(@(valueName).size)
        @(valueName).foreach {
          case (key, value) => wrapper.put(key, value)
        }
        putWrapped(@(fieldName), classOf[@(fieldGenerator.name.fullClassName)], wrapper)
      }
    }

    case _ => {
      set(@(fieldName), @(valueName))
    }

  }

}

@***********
 * Getters *
 ***********@

@getter(field: Field) = {
  @if(field.getOptional) {
    Option(
      @getterWithType(field, "GetMode.DEFAULT", generator.fieldGenerator(field))
    )
  } else {
    @getterWithType(field, "GetMode.STRICT", generator.fieldGenerator(field))
  }
}

@getterWithType(field: Field, getMode: String, fieldGenerator: TypeGenerator) = {
  @(fieldGenerator.schema.getDereferencedDataSchema) match {

    case _ : PrimitiveDataSchema => {
      obtainDirect(@(generator.fieldValName(field)), classOf[@(fieldGenerator.name.externalClassName)], @(getMode))
    }

    case _ : RecordDataSchema | _ : FixedDataSchema | _ : UnionDataSchema => {
      obtainWrapped(@(generator.fieldValName(field)), classOf[@(fieldGenerator.name.externalClassName)], @(getMode))
    }

    case _ : EnumDataSchema => {
      val name = obtainDirect(@(generator.fieldValName(field)), classOf[String], @(getMode))
      @(fieldGenerator.name.fullClassName).withName(name)
    }

    case array : ArrayDataSchema => {
      @if(array.getItems.isComplex) {
        obtainWrapped(@(generator.fieldValName(field)), classOf[@(fieldGenerator.name.fullClassName)], @(getMode)).items
      } else {
        obtainWrapped(@(generator.fieldValName(field)), classOf[@(fieldGenerator.name.fullClassName)], @(getMode)).asScala.toSeq
      }
    }

    case map : MapDataSchema => {
      @if(map.getValues.isComplex) {
        obtainWrapped(@(generator.fieldValName(field)), classOf[@(fieldGenerator.name.fullClassName)], @(getMode)).map
      } else {
        obtainWrapped(@(generator.fieldValName(field)), classOf[@(fieldGenerator.name.fullClassName)], @(getMode)).asScala.toMap.asInstanceOf[@(generator.recordTypeOf(field))]
      }
    }

    case _ => {
      get[@(fieldGenerator.name.externalClassName)](@(generator.fieldValName(field)))
    }

  }
}