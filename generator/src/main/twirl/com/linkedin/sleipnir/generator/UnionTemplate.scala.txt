@(generator: com.linkedin.sleipnir.generator.types.UnionTypeGenerator)

@import _root_.scala.collection.JavaConverters._
@import _root_.com.linkedin.data.schema.DataSchema.Type
@import _root_.com.linkedin.sleipnir.generator.types.TypeGeneratorFactory
@import _root_.com.linkedin.sleipnir.generator.types.TypeGenerator
@import _root_.com.linkedin.data.schema.PrimitiveDataSchema
@import _root_.com.linkedin.data.schema.RecordDataSchema
@import _root_.com.linkedin.data.schema.UnionDataSchema
@import _root_.com.linkedin.data.schema.FixedDataSchema
@import _root_.com.linkedin.data.schema.ArrayDataSchema
@import _root_.com.linkedin.data.schema.MapDataSchema
@import _root_.com.linkedin.data.schema.EnumDataSchema
@import _root_.com.linkedin.data.schema.TyperefDataSchema
@import _root_.com.linkedin.sleipnir.generator.helpers.txt.CustomInitializer

package @(generator.name.packageName)

import com.linkedin.data.DataMap
import com.linkedin.data.schema.UnionDataSchema
import com.linkedin.data.template.{Custom,DataTemplateUtil,UnionTemplate}

import com.linkedin.sleipnir.data.ScalaUnionTemplate

import @(generator.name.shortClassName)._


class @(generator.name.shortClassName)(data: AnyRef) extends ScalaUnionTemplate(data, Schema) {

@for(typeGenerator <- generator.referencedGenerators.filterNot(_.schema.getType == Type.NULL)) {

  def is@(typeGenerator.name.shortClassName): Boolean = memberIs("@(typeGenerator.schema.getUnionMemberKey)")

  def as@(typeGenerator.name.shortClassName): Option[@(typeGenerator.name.externalClassName)] = {
    @maybeGetterWithType(typeGenerator, generator.memberValName(typeGenerator))
  }

  def this(value: @(typeGenerator.name.externalClassName)) = {
    this(new DataMap())
    @setterWithType(typeGenerator, generator.memberValName(typeGenerator), "value")
  }

}

}


object @(generator.name.shortClassName) {

@for(typeGenerator <- generator.referencedGenerators.filterNot(_.schema.getType == Type.NULL)) {
  @CustomInitializer(typeGenerator)
}

  private val SchemaJson = "@(generator.schemaJson)"

  private val Schema = DataTemplateUtil.parseSchema(SchemaJson).asInstanceOf[UnionDataSchema]

@for(typeGenerator <- generator.referencedGenerators.filterNot(_.schema.getType == Type.NULL)) {

  private val @(generator.memberValName(typeGenerator)) = Schema.getType("@(typeGenerator.schema.getUnionMemberKey)")

  def apply(value: @(typeGenerator.name.externalClassName)): @(generator.name.shortClassName) = new @(generator.name.shortClassName)(value)

}


  @if(generator.schema.contains("null")) {
    /**
     * This constant represents 'null' value of the union.
     */
    val NullInstance = new @(generator.name.shortClassName)(null: AnyRef)
  }

  def unapply(union: @(generator.name.shortClassName)): Option[Any] = {
    union.memberType match {

    @for(typeGenerator <- generator.referencedGenerators.filterNot(_.schema.getType == Type.NULL)) {
      case @(generator.memberValName(typeGenerator)) => union.as@(typeGenerator.name.shortClassName)
    }
      case _ => None
    }

  }


}

@***********
 * Setters *
 ***********@

@setterWithType(memberGenerator: TypeGenerator, memberName: String, valueName: String) = {
  @(memberGenerator.schema) match {

    case _ : TyperefDataSchema => {
      selectDirect[@(memberGenerator.name.fullClassName)](@(memberName), classOf[@(memberGenerator.name.fullClassName)], classOf[@(memberGenerator.referencedGenerators.head.name.fullClassName)], "@(memberGenerator.schema.getUnionMemberKey)", @(valueName))
    }

    case _ : PrimitiveDataSchema | _ : TyperefDataSchema => {
      selectDirect[@(memberGenerator.name.fullClassName)](@(memberName), classOf[@(memberGenerator.name.fullClassName)], "@(memberGenerator.schema.getUnionMemberKey)", @(valueName))
    }

    case _ : RecordDataSchema | _ : FixedDataSchema | _ : UnionDataSchema => {
      selectWrapped(@(memberName), classOf[@(memberGenerator.name.externalClassName)], "@(memberGenerator.schema.getUnionMemberKey)", @(valueName))
    }

    case _ : EnumDataSchema => {
      selectDirect(@(memberName), classOf[String], "@(memberGenerator.schema.getUnionMemberKey)", @(valueName).toString)
    }

    case _ : ArrayDataSchema | _ : MapDataSchema => {
      selectWrapped(@(memberName), classOf[@(memberGenerator.name.fullClassName)], "@(memberGenerator.schema.getUnionMemberKey)", @(memberGenerator.name.fullClassName)(@(valueName)))
    }

  }

}


@***********
 * Getters *
 ***********@

@maybeGetterWithType(memberGenerator: TypeGenerator, memberName: String) = {

  if(memberIs("@memberGenerator.schema.getUnionMemberKey")) {
    Option(@getterWithType(memberGenerator, memberName))
  }
  else {
    None
  }

}

@getterWithType(memberGenerator: TypeGenerator, memberName: String) = {

  @(memberGenerator.schema) match {

    case _ : PrimitiveDataSchema | _ : TyperefDataSchema => {
      obtainDirect(@(memberName), classOf[@(memberGenerator.name.externalClassName)], "@(memberGenerator.schema.getUnionMemberKey)")
    }

    case _ : RecordDataSchema | _ : FixedDataSchema | _ : UnionDataSchema => {
      obtainWrapped(@(memberName), classOf[@(memberGenerator.name.externalClassName)], "@(memberGenerator.schema.getUnionMemberKey)")
    }

    case _ : EnumDataSchema => {
      {
        val name = obtainDirect(@(memberName), classOf[String], "@(memberGenerator.schema.getUnionMemberKey)")
        @(memberGenerator.name.fullClassName).withNameOrUnknown(name)
      }
    }

    case _ : ArrayDataSchema => {
      obtainWrapped(@(memberName), classOf[@(memberGenerator.name.fullClassName)], "@(memberGenerator.schema.getUnionMemberKey)").items
    }

    case _ : MapDataSchema => {
      obtainWrapped(@(memberName), classOf[@(memberGenerator.name.fullClassName)], "@(memberGenerator.schema.getUnionMemberKey)").map
    }

  }

}
